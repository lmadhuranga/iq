Here‚Äôs a practical guide to **Queues & Background Jobs with Redis**‚Äîusing **BullMQ** (modern, well-maintained). You‚Äôll get a runnable Node.js setup plus a NestJS version.

---

# A) Node.js + BullMQ (Producer + Worker)

## 1) Install & run Redis

```bash
npm i bullmq ioredis
docker run -d --name redis -p 6379:6379 redis:7-alpine
```

## 2) Project structure

```
queue-demo/
‚îú‚îÄ producer.js
‚îú‚îÄ worker.email.js
‚îú‚îÄ worker.thumbnail.js
‚îî‚îÄ common.js
```

## 3) `common.js` ‚Äî shared queue + connection

```js
// common.js
const { Queue, QueueScheduler, Worker } = require('bullmq');

const connection = { connection: { host: '127.0.0.1', port: 6379 } };

// You can have multiple queues by name
const emailQueue = new Queue('email', connection);
new QueueScheduler('email', connection);        // ensures delayed/retries work

const thumbnailQueue = new Queue('thumbnail', connection);
new QueueScheduler('thumbnail', connection);

module.exports = { Queue, Worker, emailQueue, thumbnailQueue, connection };
```

## 4) `producer.js` ‚Äî enqueue jobs

```js
// producer.js
const { emailQueue, thumbnailQueue } = require('./common');

(async () => {
  // basic job
  await emailQueue.add('send-welcome', { to: 'user@example.com' }, { attempts: 3, backoff: { type: 'exponential', delay: 2000 } });

  // delayed job (run in 30s)
  await emailQueue.add('send-digest', { to: 'vip@example.com' }, { delay: 30_000 });

  // prioritized jobs (5 > 1)
  await thumbnailQueue.add('thumb', { file: 'a.jpg' }, { priority: 1 });
  await thumbnailQueue.add('thumb', { file: 'urgent.jpg' }, { priority: 5 });

  // repeat job (cron every minute)
  await emailQueue.add(
    'send-cron-digest',
    { segment: 'daily' },
    { repeat: { cron: '* * * * *' }, removeOnComplete: true }
  );

  console.log('‚úÖ jobs enqueued');
  process.exit(0);
})();
```

## 5) `worker.email.js` ‚Äî worker with concurrency + cleanup

```js
// worker.email.js
const { Worker, connection } = require('./common');

const emailWorker = new Worker(
  'email',
  async job => {
    if (job.name === 'send-welcome') {
      // simulate send
      await new Promise(r => setTimeout(r, 500));
      console.log('üìß welcome sent to', job.data.to);
    } else if (job.name === 'send-digest') {
      console.log('üóûÔ∏è digest to', job.data.to);
    } else if (job.name === 'send-cron-digest') {
      console.log('‚è∞ cron digest run for', job.data.segment);
    }
  },
  { ...connection, concurrency: 5 } // process 5 jobs in parallel
);

emailWorker.on('completed', job => console.log('‚úÖ email completed', job.id));
emailWorker.on('failed', (job, err) => console.error('‚ùå email failed', job?.id, err.message));

// graceful shutdown
process.on('SIGINT', async () => { await emailWorker.close(); process.exit(0); });
```

## 6) `worker.thumbnail.js` ‚Äî rate limit + retries

```js
// worker.thumbnail.js
const { Worker, connection } = require('./common');

const thumbWorker = new Worker(
  'thumbnail',
  async job => {
    // simulate work & occasional error
    if (job.attemptsMade < 1 && job.data.file === 'a.jpg') throw new Error('transient error');
    await new Promise(r => setTimeout(r, 300));
    console.log('üñºÔ∏è generated thumbnail for', job.data.file);
  },
  {
    ...connection,
    concurrency: 10,
    limiter: { max: 20, duration: 1000 }, // ‚â§20 jobs/sec
  }
);

thumbWorker.on('completed', job => console.log('‚úÖ thumb completed', job.id));
thumbWorker.on('failed', (job, err) => console.error('‚ùå thumb failed', job?.id, err.message));

process.on('SIGINT', async () => { await thumbWorker.close(); process.exit(0); });
```

## 7) Run

```bash
node worker.email.js &
node worker.thumbnail.js &
node producer.js
```

**What you‚Äôve got:**

* Delayed jobs, retries with exponential backoff
* Priorities, rate limiting, concurrency
* Cron-like repeaters
* QueueScheduler for reliability

---

# B) NestJS + BullMQ (clean integration)

## 1) Install

```bash
npm i @nestjs/bullmq bullmq ioredis
```

## 2) `app.module.ts`

```ts
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bullmq';
import { EmailProcessor } from './email.processor';
import { QueueService } from './queue.service';

@Module({
  imports: [
    BullModule.forRoot({
      connection: { host: '127.0.0.1', port: 6379 },
    }),
    BullModule.registerQueue(
      { name: 'email' },
      { name: 'thumbnail' },
    ),
  ],
  providers: [EmailProcessor, QueueService],
})
export class AppModule {}
```

## 3) `queue.service.ts` ‚Äî enqueue from controllers/services

```ts
import { Injectable } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bullmq';
import { Queue } from 'bullmq';

@Injectable()
export class QueueService {
  constructor(
    @InjectQueue('email') private emailQueue: Queue,
    @InjectQueue('thumbnail') private thumbnailQueue: Queue,
  ) {}

  addWelcomeEmail(to: string) {
    return this.emailQueue.add('send-welcome', { to }, { attempts: 3, backoff: { type: 'exponential', delay: 2000 } });
  }

  scheduleDigest(to: string) {
    return this.emailQueue.add('send-digest', { to }, { delay: 30_000 });
  }

  addThumbnail(file: string) {
    return this.thumbnailQueue.add('thumb', { file }, { priority: 1 });
  }
}
```

## 4) `email.processor.ts` ‚Äî worker (processor)

```ts
import { Processor, WorkerHost, OnWorkerEvent } from '@nestjs/bullmq';

@Processor('email')
export class EmailProcessor extends WorkerHost {
  // optional: set concurrency via @Processor({ name: 'email', concurrency: 5 })
  async process(job: any): Promise<void> {
    switch (job.name) {
      case 'send-welcome':
        await new Promise(r => setTimeout(r, 500));
        console.log('üìß welcome sent to', job.data.to);
        break;
      case 'send-digest':
        console.log('üóûÔ∏è digest to', job.data.to);
        break;
    }
  }

  @OnWorkerEvent('completed')
  onCompleted(job: any) {
    console.log('‚úÖ completed', job.id);
  }
  @OnWorkerEvent('failed')
  onFailed(job: any, err: Error) {
    console.error('‚ùå failed', job?.id, err.message);
  }
}
```

Use `QueueService` from a controller to enqueue.

---

## Extra patterns (quick hits)

* **Idempotency:** include a `jobId` (e.g., orderId) to prevent duplicates:

  ```js
  queue.add('charge', { orderId }, { jobId: `order:${orderId}` });
  ```
* **Remove completed jobs:** `removeOnComplete: true`; keep a small `removeOnFail: 100`.
* **Observability:** expose Bull Board / custom metrics (active, waiting, failed).
* **Graceful shutdown:** call `worker.close()` on SIGINT/SIGTERM.
* **Payload size:** keep small; store large blobs in S3 and pass pointers.
* **Exactly-once?** Not guaranteed‚Äîdesign processors to be **at-least-once** safe.
* **Security:** Redis should be private/VPC; enable AUTH/TLS on managed Redis.

---

Want a **Bull Board UI** snippet or a **Redis Streams (consumer groups) example** next?
