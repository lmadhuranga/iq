Awesome—here are **practical Redis-powered rate limiters** for Node.js you can drop into an Express app. They use atomic `INCR` + `EXPIRE` for speed and work across multiple servers.

---

# 1) Setup

```bash
npm i express redis
docker run -d --name redis -p 6379:6379 redis:7-alpine
```

---

# 2) Fixed-Window limiter (simple + fast)

* Limits requests per **IP** (or per **userId**) in a time window.
* Uses `INCR` (first hit sets count to 1) and `EXPIRE` (sets TTL on first hit).

```js
// rateLimit.js
const { createClient } = require('redis');

const redis = createClient({ url: process.env.REDIS_URL || 'redis://localhost:6379' });
redis.on('error', (e) => console.error('Redis error:', e));
(async () => { await redis.connect(); })();

// factory: limit N requests per WINDOW seconds
function rateLimit({ limit = 100, windowSec = 60, keyBy = (req) => req.ip, prefix = 'rl' }) {
  return async (req, res, next) => {
    try {
      const id = keyBy(req); // e.g., req.ip or req.user.id
      const key = `${prefix}:${id}`;
      // atomic-ish: get count, set TTL only on first visit
      const count = await redis.incr(key);
      if (count === 1) await redis.expire(key, windowSec);

      const remaining = Math.max(0, limit - count);
      // helpful headers (RFC-ish)
      res.setHeader('X-RateLimit-Limit', limit);
      res.setHeader('X-RateLimit-Remaining', remaining);
      const ttl = await redis.ttl(key);
      if (ttl >= 0) res.setHeader('X-RateLimit-Reset', Math.ceil(Date.now() / 1000) + ttl);

      if (count > limit) return res.status(429).json({ error: 'Too Many Requests' });
      next();
    } catch (err) {
      console.warn('RateLimit error, allowing request:', err.message);
      next(); // fail-open
    }
  };
}

module.exports = { rateLimit, redis };
```

**Use it:**

```js
// index.js
const express = require('express');
const { rateLimit } = require('./rateLimit');

const app = express();
app.use(express.json());

// 60 requests / minute per IP for all routes
app.use(rateLimit({ limit: 60, windowSec: 60 }));

app.get('/public', (req, res) => res.json({ ok: true }));

app.listen(3000, () => console.log('http://localhost:3000'));
```

Test:

```bash
for i in {1..65}; do curl -s -o /dev/null -w "%{http_code}\n" http://localhost:3000/public; done
# last few should be 429
```

---

# 3) Login attempt limiter (per username or IP)

* Prevents brute-force by capping attempts, e.g., **5 attempts / 10 minutes**.
* On success, delete the counter.

```js
// loginLimiter.js
const { redis } = require('./rateLimit');

function loginLimiter({ attempts = 5, windowSec = 600, prefix = 'login' }) {
  return async (req, res, next) => {
    const identifier = (req.body?.username || req.ip || 'unknown').toLowerCase();
    const key = `${prefix}:${identifier}`;

    try {
      const tries = await redis.incr(key);
      if (tries === 1) await redis.expire(key, windowSec);

      const ttl = await redis.ttl(key);
      if (tries > attempts) {
        return res.status(429).json({
          error: 'Too many login attempts',
          retry_after_seconds: ttl >= 0 ? ttl : windowSec
        });
      }

      // let the route handler attempt auth; it should call onSuccess/onFail
      req.loginLimit = {
        async onSuccess() { await redis.del(key); },
        async onFail() { /* keep counter */ },
        remaining: Math.max(0, attempts - tries),
        reset_in: ttl
      };
      next();
    } catch (e) {
      console.warn('LoginLimiter error:', e.message);
      next(); // fail-open
    }
  };
}

module.exports = { loginLimiter };
```

**Use it in an auth route:**

```js
// authRoutes.js
const express = require('express');
const { loginLimiter } = require('./loginLimiter');

const router = express.Router();

router.post('/login', loginLimiter({ attempts: 5, windowSec: 600 }), async (req, res) => {
  const { username, password } = req.body;

  // fake check
  const ok = username === 'rohit' && password === 'secret';

  if (!ok) {
    await req.loginLimit.onFail();
    return res.status(401).json({
      error: 'invalid credentials',
      remaining_attempts: req.loginLimit.remaining,
      reset_in_seconds: req.loginLimit.reset_in
    });
  }

  await req.loginLimit.onSuccess();
  res.json({ ok: true });
});

module.exports = router;
```

Wire it up:

```js
// index.js (extended)
const express = require('express');
const { rateLimit } = require('./rateLimit');
const authRoutes = require('./authRoutes');

const app = express();
app.use(express.json());

// global API limit (e.g., 100/min)
app.use(rateLimit({ limit: 100, windowSec: 60 }));

app.use('/auth', authRoutes);

app.get('/data', (req, res) => res.json({ data: 'hello' }));

app.listen(3000, () => console.log('http://localhost:3000'));
```

---

# 4) Token-Bucket (smoother traffic) — optional Lua script

* Avoids “burstiness” of fixed windows.
* Redis script keeps operations atomic.

```js
// tokenBucket.js
const { redis } = require('./rateLimit');

/**
 * capacity: max tokens in bucket
 * refillRate: tokens per second
 * cost: tokens needed per request
 */
function tokenBucket({ capacity = 20, refillRate = 5, cost = 1, prefix = 'tb', keyBy = (req)=>req.ip }) {
  const script = `
    local key = KEYS[1]
    local now = tonumber(ARGV[1])
    local capacity = tonumber(ARGV[2])
    local refill = tonumber(ARGV[3])
    local cost = tonumber(ARGV[4])

    local bucket = redis.call('HMGET', key, 'tokens', 'ts')
    local tokens = tonumber(bucket[1]) or capacity
    local ts = tonumber(bucket[2]) or now

    local delta = math.max(0, now - ts)
    local filled = math.min(capacity, tokens + delta * refill)
    local allowed = filled >= cost
    if allowed then
      filled = filled - cost
    end

    redis.call('HMSET', key, 'tokens', filled, 'ts', now)
    redis.call('EXPIRE', key, 3600)

    return { allowed and 1 or 0, filled }
  `;

  return async (req, res, next) => {
    try {
      const id = keyBy(req);
      const key = `${prefix}:${id}`;
      const now = Math.floor(Date.now() / 1000);

      const [allowed, remaining] = await redis.eval(script, {
        keys: [key],
        arguments: [now, capacity, refillRate, cost]
      });

      res.setHeader('X-RateLimit-Remaining-Tokens', remaining);

      if (allowed === 0) return res.status(429).json({ error: 'Rate limit exceeded (token bucket)' });
      next();
    } catch (e) {
      console.warn('TokenBucket error, allowing:', e.message);
      next();
    }
  };
}

module.exports = { tokenBucket };
```

Use it on a hot route:

```js
const { tokenBucket } = require('./tokenBucket');
// e.g., 10 req burst, refills 2 tokens/sec
app.get('/hot', tokenBucket({ capacity: 10, refillRate: 2 }), (req, res) => {
  res.json({ ok: true });
});
```

---

## Tips & best practices

* Put **global** limiter (per IP) + **route-specific** stricter limiters (e.g., `/auth/login`).
* Return helpful headers: `X-RateLimit-*`, `Retry-After`.
* Distinguish keys by **userId** (if authenticated) or **IP** (anonymous).
* For multi-tenant/SaaS quotas: add `tenantId` to the key.
* Prefer **token bucket** for smoother traffic; fixed window for simplicity.
* Always run behind HTTPS and a reverse proxy that sets `X-Forwarded-For`; call `app.set('trust proxy', 1)` in Express.

Want me to convert these into a **NestJS Guard/Interceptor** version with providers and config?
