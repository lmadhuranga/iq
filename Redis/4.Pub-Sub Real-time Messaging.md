Here’s a crisp, working **Redis Pub/Sub** setup for real-time messaging in Node.js—plus a Socket.io bridge and a NestJS variant.

---

# A) Minimal Pub/Sub (two Node scripts)

## 1) Install & run Redis

```bash
npm i redis
docker run -d --name redis -p 6379:6379 redis:7-alpine
```

## 2) `subscriber.js`

```js
const { createClient } = require('redis');

(async () => {
  const sub = createClient({ url: 'redis://localhost:6379' });
  await sub.connect();

  await sub.subscribe('news', (message, channel) => {
    console.log(`[${channel}] ${message}`);
  });

  console.log('✅ Subscribed to "news"');
})();
```

## 3) `publisher.js`

```js
const { createClient } = require('redis');

(async () => {
  const pub = createClient({ url: 'redis://localhost:6379' });
  await pub.connect();

  await pub.publish('news', JSON.stringify({ type: 'ping', at: Date.now() }));
  await pub.publish('news', 'hello world');
  console.log('✅ Published 2 messages');  
  await pub.quit();
})();
```

Run:

```bash
node subscriber.js
node publisher.js
```

---

# B) Bridge Redis → Web clients (Express + Socket.io)

```bash
npm i express socket.io redis
```

## `server.js`

```js
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const { createClient } = require('redis');

const app = express();
const server = http.createServer(app);
const io = new Server(server, { cors: { origin: '*' } });

(async () => {
  const sub = createClient({ url: 'redis://localhost:6379' });
  const pub = createClient({ url: 'redis://localhost:6379' });
  await sub.connect();
  await pub.connect();

  // Broadcast Redis messages to all web sockets
  await sub.subscribe('chat', (msg) => {
    io.emit('chat', msg);
  });

  io.on('connection', (socket) => {
    console.log('🔌 client connected');

    // From web → publish into Redis channel
    socket.on('chat', async (msg) => {
      await pub.publish('chat', msg);
    });
  });
})();

app.get('/', (_, res) => res.send('OK'));
server.listen(3000, () => console.log('🚀 http://localhost:3000'));
```

Quick client test in browser console:

```js
const s = io('http://localhost:3000');
s.on('chat', m => console.log('recv:', m));
s.emit('chat', 'hi from browser');
```

---

# C) NestJS microservice style (Pub/Sub in a provider)

```bash
npm i redis
```

## `redis.pubsub.ts`

```ts
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { createClient, RedisClientType } from 'redis';

@Injectable()
export class RedisPubSub implements OnModuleInit, OnModuleDestroy {
  private pub!: RedisClientType;
  private sub!: RedisClientType;

  async onModuleInit() {
    this.pub = createClient({ url: process.env.REDIS_URL || 'redis://localhost:6379' });
    this.sub = createClient({ url: process.env.REDIS_URL || 'redis://localhost:6379' });
    await this.pub.connect();
    await this.sub.connect();
  }

  async onModuleDestroy() {
    await this.pub.quit();
    await this.sub.quit();
  }

  async publish(channel: string, payload: any) {
    await this.pub.publish(channel, typeof payload === 'string' ? payload : JSON.stringify(payload));
  }

  async subscribe(channel: string, handler: (msg: string) => void) {
    await this.sub.subscribe(channel, handler);
  }
}
```

## Use it in a module/controller

```ts
// app.module.ts
import { Module } from '@nestjs/common';
import { RedisPubSub } from './redis.pubsub';
import { AppService } from './app.service';
import { AppController } from './app.controller';

@Module({ providers: [RedisPubSub, AppService], controllers: [AppController] })
export class AppModule {}
```

```ts
// app.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { RedisPubSub } from './redis.pubsub';

@Injectable()
export class AppService implements OnModuleInit {
  constructor(private readonly bus: RedisPubSub) {}
  async onModuleInit() {
    await this.bus.subscribe('orders.created', (msg) => {
      console.log('order event:', msg);
    });
  }
  async createOrder() {
    await this.bus.publish('orders.created', { id: Date.now() });
    return { ok: true };
  }
}
```

---

## Patterns & tips (fast take)

* **Channel naming:** `domain.event` (e.g., `orders.created`, `chat.room.42`).
* **Fan-out:** One publisher → many subscribers across services.
* **Stateless workers:** Scale subscribers horizontally.
* **Idempotency:** Subscribers should handle duplicate messages safely.
* **Observability:** Log channel, payload size, and processing time.
* **Security:** Don’t expose Redis directly to the internet; use a backend to gate messages.

> ⚠️ **Durability note:** Redis Pub/Sub is **ephemeral** (missed if offline).
> Need persistence/replay? Use **Redis Streams** (XADD/XREADGROUP) or a broker like **Kafka/RabbitMQ**.

Want a Redis **Streams** example next (consumer groups + at-least-once)?
