Here’s how to do **Session Management with Redis** — quick and practical.

# Why Redis for sessions

* Fast read/write (RAM)
* TTL-based expiry
* Works across multiple app instances (stateless servers)

---

# A) Express.js + `express-session` + `connect-redis`

## 1) Install

```bash
npm i express express-session redis connect-redis
```

## 2) Minimal server (`index.js`)

```js
const express = require('express');
const session = require('express-session');
const { createClient } = require('redis');
const RedisStore = require('connect-redis').default;

const app = express();
app.use(express.json());

// 1) Redis client
const redis = createClient({ url: process.env.REDIS_URL || 'redis://localhost:6379' });
redis.connect();

// 2) Session store
const store = new RedisStore({ client: redis, prefix: 'sess:' });

// 3) Session middleware
app.use(session({
  store,
  name: 'sid',                    // cookie name
  secret: process.env.SESSION_SECRET || 'change-me',
  resave: false,
  saveUninitialized: false,
  cookie: {
    httpOnly: true,
    secure: false,                // true behind HTTPS / proxy
    sameSite: 'lax',
    maxAge: 1000 * 60 * 30        // 30 minutes
  },
}));

// 4) Login: create session (rotate to prevent fixation)
app.post('/login', async (req, res) => {
  // fake auth
  const user = { id: 1, role: 'user', name: 'Rohit' };
  req.session.regenerate(err => {
    if (err) return res.status(500).send('error');
    req.session.user = { id: user.id, role: user.role };
    res.json({ ok: true });
  });
});

// 5) Guard middleware
function auth(req, res, next) {
  if (req.session?.user) return next();
  res.status(401).json({ error: 'unauthorized' });
}

// 6) Protected route
app.get('/me', auth, (req, res) => {
  res.json({ user: req.session.user });
});

// 7) Logout: destroy + clear cookie
app.post('/logout', (req, res) => {
  req.session.destroy(() => {
    res.clearCookie('sid');
    res.json({ ok: true });
  });
});

app.listen(3000, () => console.log('http://localhost:3000'));
```

That’s it: sessions live in Redis (`sess:<id>`), expire automatically, and work across many Node processes.

---

# B) NestJS (Express) with Redis sessions

## 1) Install

```bash
npm i express-session redis connect-redis
```

## 2) `main.ts`

```ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import * as session from 'express-session';
import { createClient } from 'redis';
import RedisStoreFactory from 'connect-redis';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  const redis = createClient({ url: process.env.REDIS_URL || 'redis://localhost:6379' });
  await redis.connect();
  const RedisStore = RedisStoreFactory(session);

  app.use(session({
    store: new RedisStore({ client: redis, prefix: 'sess:' }),
    name: 'sid',
    secret: process.env.SESSION_SECRET || 'change-me',
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true,
      secure: false,            // set true behind HTTPS
      sameSite: 'lax',
      maxAge: 1000 * 60 * 30,
    },
  }));

  await app.listen(3000);
}
bootstrap();
```

Use standard guards/decorators to check `req.session.user` inside controllers.

---

# C) Best practices (super short)

* **Rotate session on login** (`req.session.regenerate`) to prevent fixation.
* **Secure cookies**: `secure: true` (HTTPS), `httpOnly: true`, `sameSite: 'lax'|'strict'`.
* **Short TTL** + **sliding sessions** (touch on each request if needed).
* **Store minimal data** (user id/role only).
* **Set `X-Forwarded-Proto`/trust proxy** if behind a load balancer.
* **Use strong `SESSION_SECRET`** and rotate periodically.

---

Want me to add **sliding expiration**, or a **JWT + Redis** example (store refresh tokens / blacklist invalidated tokens)?
