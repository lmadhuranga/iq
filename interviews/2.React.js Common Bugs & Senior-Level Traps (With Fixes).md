## React.js Common Bugs & Senior-Level Traps (With Fixes)

## 1ï¸âƒ£ useEffect Infinite Loop âŒ

**Question**

```jsx
useEffect(() => {
  setCount(count + 1);
}, [count]);
```

**Error**

* Infinite re-render loop

**Fix**

```jsx
useEffect(() => {
  setCount(c => c + 1);
}, []);
```

---

## 2ï¸âƒ£ Stale Closure Bug âŒ

**Question**

```jsx
useEffect(() => {
  setTimeout(() => {
    console.log(count);
  }, 1000);
}, []);
```

**Error**

* `count` is stale (always initial value)

**Fix**

```jsx
useEffect(() => {
  const id = setTimeout(() => console.log(count), 1000);
  return () => clearTimeout(id);
}, [count]);
```

---

## 3ï¸âƒ£ Missing Cleanup (Memory Leak) âŒ

**Question**

```jsx
useEffect(() => {
  setInterval(() => {
    console.log("tick");
  }, 1000);
}, []);
```

**Error**

* Interval never cleared

**Fix**

```jsx
useEffect(() => {
  const id = setInterval(() => console.log("tick"), 1000);
  return () => clearInterval(id);
}, []);
```

---

## 4ï¸âƒ£ Wrong Key Usage âŒ

**Question**

```jsx
items.map((item, index) => (
  <li key={index}>{item}</li>
));
```

**Error**

* Index as key breaks reconciliation

**Fix**

```jsx
items.map(item => (
  <li key={item.id}>{item.name}</li>
));
```

---

## 5ï¸âƒ£ State Mutation âŒ

**Question**

```jsx
state.count++;
setState(state);
```

**Error**

* Mutating state directly

**Fix**

```jsx
setState(prev => ({ ...prev, count: prev.count + 1 }));
```

---

## 6ï¸âƒ£ Wrong useMemo Usage âŒ

**Question**

```jsx
const value = useMemo(() => {
  return compute(data);
}, []);
```

**Error**

* Missing dependency

**Fix**

```jsx
const value = useMemo(() => compute(data), [data]);
```

---

## 7ï¸âƒ£ useCallback Trap âŒ

**Question**

```jsx
const handleClick = useCallback(() => {
  console.log(count);
}, []);
```

**Error**

* `count` is stale

**Fix**

```jsx
const handleClick = useCallback(() => {
  console.log(count);
}, [count]);
```

---

## 8ï¸âƒ£ useRef Misuse âŒ

**Question**

```jsx
const [count, setCount] = useRef(0);
```

**Error**

* `useRef` does NOT return array

**Fix**

```jsx
const count = useRef(0);
```

---

## 9ï¸âƒ£ Event Handler Executed Immediately âŒ

**Question**

```jsx
<button onClick={handleClick()}>
  Click
</button>
```

**Error**

* Function executed during render

**Fix**

```jsx
<button onClick={handleClick}>
  Click
</button>
```

---

## ğŸ”Ÿ Controlled vs Uncontrolled Input âŒ

**Question**

```jsx
<input value={text} />
```

**Error**

* Missing `onChange`

**Fix**

```jsx
<input value={text} onChange={e => setText(e.target.value)} />
```

---

## 1ï¸âƒ£1ï¸âƒ£ Conditional Hook âŒ

**Question**

```jsx
if (isLoggedIn) {
  useEffect(() => {
    fetchData();
  }, []);
}
```

**Error**

* Hooks cannot be conditional

**Fix**

```jsx
useEffect(() => {
  if (isLoggedIn) fetchData();
}, [isLoggedIn]);
``` 

## 1ï¸âƒ£3ï¸âƒ£ Async useEffect âŒ

**Question**

```jsx
useEffect(async () => {
  const data = await fetchData();
}, []);
```

**Error**

* `useEffect` callback cannot be async

**Fix**

```jsx
useEffect(() => {
  (async () => {
    await fetchData();
  })();
}, []);
```
---

## 1ï¸âƒ£4ï¸âƒ£ setState Based on Old State âŒ

**Question**

```jsx
setCount(count + 1);
setCount(count + 1);
```
**Error**

### Reactâ€™s internal thinking:
-   Both updates use the **same snapshot** of `count`
-   React **batches** them into one render
-   Last update wins â†’ `1`
    

> React does **NOT** update state immediately  
> State updates are **queued**, not applied instantly

* Batching causes same value

**Fix**

```jsx
setCount(c => c + 1);
setCount(c => c + 1);
```
```
- Why this works
- Each update gets the **latest value**
- React executes them in order
```
---

## 1ï¸âƒ£5ï¸âƒ£ Missing Dependency Warning âŒ

**Question**

```jsx
useEffect(() => {
  fetchData(id);
}, []);
```

**Error**

* `id` missing dependency

**Fix**

```jsx
useEffect(() => {
  fetchData(id);
}, [id]);
```
---
### ğŸ§  1ï¸âƒ£ Stale Closure in Event Listener (VERY COMMON)

### âŒ Buggy Code

```jsx
useEffect(() => {
  const handler = () => {
    console.log(count);
  };
  window.addEventListener("click", handler);
}, []);
```
### â“ Whatâ€™s wrong?

-   `count` is captured once
-   Always logs initial value
    

### âœ… Fix

```jsx
useEffect(() => {
  const handler = () => console.log(count);
  window.addEventListener("click", handler);
  return () => window.removeEventListener("click", handler);
}, [count]);

```

----------

## ğŸ§  2ï¸âƒ£ React.memo False Sense of Optimization

### âŒ Buggy Code

```jsx
const Child = React.memo(({ user }) => {
  console.log("Rendered");
  return <p>{user.name}</p>;
});

<Child user={{ name: "John" }} />

```

### â“ Whatâ€™s wrong?

-   New object reference every render
    
-   `React.memo` useless
    

### âœ… Fix

```jsx
const user = useMemo(() => ({ name: "John" }), []);
<Child user={user} />

```

----------

## ğŸ§  3ï¸âƒ£ useEffect Runs Twice in React 18 (Trap Question)

### âŒ â€œBugâ€

```jsx
useEffect(() => {
  console.log("API called");
}, []);

```

### â“ Why does this run twice?

-   React 18 StrictMode    
-   Detects unsafe side effects
    

### âœ… Correct Answer

> Not a bug. Happens only in **development**, never in production.

----------

## ğŸ§  4ï¸âƒ£ Async Race Condition (Hard)

### âŒ Buggy Code

```jsx
useEffect(() => {
  fetchUser(id).then(setUser);
}, [id]);

```

### â“ Whatâ€™s wrong?

-   Old request may finish after new one
    
-   Overwrites latest data
    

### âœ… Fix (AbortController)

```jsx
useEffect(() => {
  const controller = new AbortController();

  fetchUser(id, controller.signal).then(setUser);
  return () => controller.abort();
}, [id]);

```

----------

## ğŸ§  5ï¸âƒ£ Context Re-render Explosion

### âŒ Buggy Code

```jsx
<AuthContext.Provider value={{ user, logout }}>

```

### â“ Whatâ€™s wrong?

-   New object every render  
-   All consumers re-render
    

### âœ… Fix

```jsx
const value = useMemo(() => ({ user, logout }), [user, logout]);

```
----------

## ğŸ§  7ï¸âƒ£ useCallback Overuse (Performance Regression)

### âŒ Buggy Code

```jsx
const fn = useCallback(() => {
  heavyWork();
}, []);

```

### â“ Whatâ€™s wrong?

-   `heavyWork` recreated anyway
    
-   useCallback adds memory cost
    

### âœ… Correct Insight

> useCallback helps **only when passing props to memoized children**

----------

## ğŸ§  8ï¸âƒ£ Derived State Anti-Pattern

### âŒ Buggy Code

```jsx
const [fullName, setFullName] = useState(
  firstName + " " + lastName
);

```

### â“ Whatâ€™s wrong?

-   State derived from state
    
-   Sync bugs
    

### âœ… Fix

```jsx
const fullName = `${firstName} ${lastName}`;

``` 
----------

## ğŸ§  1ï¸âƒ£1ï¸âƒ£ Refs Used Instead of State (Wrong)

### âŒ Buggy Code

```jsx
const count = useRef(0);
return <p>{count.current}</p>;

```

### â“ Whatâ€™s wrong?

-   Ref changes donâ€™t re-render
    

### âœ… Fix

Use `useState` for UI data.

----------

## ğŸ§  1ï¸âƒ£2ï¸âƒ£ Memoizing JSX (Useless)

### âŒ Buggy Code

```jsx
const view = useMemo(() => <Child />, []);

```

### â“ Whatâ€™s wrong?

-   JSX creation is cheap
    
-   Memo gives no benefit
    

### âœ… Correct Insight

> Memoize **values**, not JSX.

---------- 
